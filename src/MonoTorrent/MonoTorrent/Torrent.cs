//
// Torrent.cs
//
// Authors:
//   Alan McGovern alan.mcgovern@gmail.com
//
// Copyright (C) 2006 Alan McGovern
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//


using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

using MonoTorrent.BEncoding;

namespace MonoTorrent
{
    public class Torrent : IEquatable<Torrent>, ITorrentData
    {
        #region Private Fields

        BEncodedDictionary originalDictionary;
        DateTime creationDate;
        protected string name;
        protected int pieceLength;
        protected Hashes pieces;
        protected long size;
        protected TorrentFile[] torrentFiles;
        protected string torrentPath;

        #endregion Private Fields


        #region Properties

        internal byte[] Metadata { get; set; }

        /// <summary>
        /// The announce URLs contained within the .torrent file
        /// </summary>
        public IList<RawTrackerTier> AnnounceUrls { get; }


        /// <summary>
        /// This dictionary is specific for azureus client 
        /// It can contain 
        /// 	dht_backup_enable (number)
        /// 	Content (dictionnary)
        ///  		Publisher
        /// 		Description
        /// 		Title
        /// 		Creation Date
        /// 		Content Hash
        /// 		Revision Date
        /// 		Thumbnail (string) = Base64 encoded image
        /// 		Progressive
        /// 		Speed Bps (number)
        /// but not useful for MT
        /// </summary>
        public BEncodedValue AzureusProperties { get; set; }


        /// <summary>
        /// The comment contained within the .torrent file
        /// </summary>
        public string Comment { get; set; }


        /// <summary>
        /// The optional string showing who/what created the .torrent
        /// </summary>
        public string CreatedBy { get; set; }


        /// <summary>
        /// The creation date of the .torrent file
        /// </summary>
        public DateTime CreationDate => creationDate;


        /// <summary>
        /// The optional ED2K hash contained within the .torrent file
        /// </summary>
        public byte[] ED2K { get; set; }


        /// <summary>
        /// The encoding used by the client that created the .torrent file
        /// </summary>
        public string Encoding { get; set; }


        /// <summary>
        /// The list of files contained within the .torrent which are available for download
        /// </summary>
        public TorrentFile[] Files => torrentFiles;


        /// <summary>
        /// This is the infohash that is generated by putting the "Info" section of a .torrent
        /// through a ManagedSHA1 hasher.
        /// </summary>
        public InfoHash InfoHash { get; set; }


        /// <summary>
        /// Shows whether DHT is allowed or not. If it is a private torrent, no peer
        /// sharing should be allowed.
        /// </summary>
        public bool IsPrivate { get; set; }


        /// <summary>
        /// In the case of a single file torrent, this is the name of the file.
        /// In the case of a multi file torrent, it is the name of the root folder.
        /// </summary>
        public string Name {
            get => name;
            private set => name = value;
        }


        /// <summary>
        /// FIXME: No idea what this is.
        /// </summary>
        public BEncodedList Nodes { get; set; }


        /// <summary>
        /// The length of each piece in bytes.
        /// </summary>
        public int PieceLength => pieceLength;


        /// <summary>
        /// This is the array of hashes contained within the torrent.
        /// </summary>
        public Hashes Pieces => pieces;


        /// <summary>
        /// The name of the Publisher
        /// </summary>
        public string Publisher { get; set; }


        /// <summary>
        /// The Url of the publisher of either the content or the .torrent file
        /// </summary>
        public string PublisherUrl { get; set; }


        /// <summary>
        /// The optional SHA1 hash contained within the .torrent file
        /// </summary>
        public byte[] SHA1 { get; set; }


        /// <summary>
        /// The total size of all the files that have to be downloaded.
        /// </summary>
        public long Size {
            get => size;
            private set => size = value;
        }


        /// <summary>
        /// The source of the .torrent file
        /// </summary>
        public string Source { get; set; }


        /// <summary>
        /// This is the path at which the .torrent file is located
        /// </summary>
        public string TorrentPath {
            get => torrentPath;
            internal set => torrentPath = value;
        }

        /// <summary>
        /// This is the http-based seeding (getright protocole)
        /// </summary>
        public List<string> GetRightHttpSeeds { get; }

        #endregion Properties


        #region Constructors

        protected Torrent ()
        {
            AnnounceUrls = new RawTrackerTiers ();
            Comment = string.Empty;
            CreatedBy = string.Empty;
            creationDate = new DateTime (1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
            Encoding = string.Empty;
            name = string.Empty;
            Publisher = string.Empty;
            PublisherUrl = string.Empty;
            Source = string.Empty;
            GetRightHttpSeeds = new List<string> ();
        }

        #endregion


        #region Public Methods

        public override bool Equals (object obj)
        {
            return Equals (obj as Torrent);
        }

        public bool Equals (Torrent other)
        {
            if (other == null)
                return false;

            return InfoHash == other.InfoHash;
        }

        public override int GetHashCode ()
        {
            return InfoHash.GetHashCode ();
        }

        internal byte[] ToBytes ()
        {
            return originalDictionary.Encode ();
        }

        internal BEncodedDictionary ToDictionary ()
        {
            // Give the user a copy of the original dictionary.
            return BEncodedValue.Clone (originalDictionary);
        }

        public override string ToString ()
        {
            return name;
        }

        #endregion Public Methods


        #region Private Methods

        /// <summary>
        /// This method is called internally to read out the hashes from the info section of the
        /// .torrent file.
        /// </summary>
        /// <param name="data">The byte[]containing the hashes from the .torrent file</param>
        void LoadHashPieces (byte[] data)
        {
            if (data.Length % 20 != 0)
                throw new TorrentException ("Invalid infohash detected");

            pieces = new Hashes (data, data.Length / 20);
        }


        /// <summary>
        /// This method is called internally to load in all the files found within the "Files" section
        /// of the .torrents infohash
        /// </summary>
        /// <param name="list">The list containing the files available to download</param>
        void LoadTorrentFiles (BEncodedList list)
        {
            var files = new List<TorrentFile> ();
            int endIndex;
            long length;
            string path;
            byte[] md5sum;
            byte[] ed2k;
            byte[] sha1;
            int startIndex;
            var sb = new StringBuilder (32);

            foreach (BEncodedDictionary dict in list) {
                length = 0;
                path = null;
                md5sum = null;
                ed2k = null;
                sha1 = null;

                foreach (KeyValuePair<BEncodedString, BEncodedValue> keypair in dict) {
                    switch (keypair.Key.Text) {
                        case ("sha1"):
                            sha1 = ((BEncodedString) keypair.Value).TextBytes;
                            break;

                        case ("ed2k"):
                            ed2k = ((BEncodedString) keypair.Value).TextBytes;
                            break;

                        case ("length"):
                            length = long.Parse (keypair.Value.ToString ());
                            break;

                        case ("path.utf-8"):
                            foreach (BEncodedString str in ((BEncodedList) keypair.Value)) {
                                sb.Append (str.Text);
                                sb.Append (Path.DirectorySeparatorChar);
                            }
                            path = sb.ToString (0, sb.Length - 1);
                            sb.Remove (0, sb.Length);
                            break;

                        case ("path"):
                            if (string.IsNullOrEmpty (path)) {
                                foreach (BEncodedString str in ((BEncodedList) keypair.Value)) {
                                    sb.Append (str.Text);
                                    sb.Append (Path.DirectorySeparatorChar);
                                }
                                path = sb.ToString (0, sb.Length - 1);
                                sb.Remove (0, sb.Length);
                            }
                            break;

                        case ("md5sum"):
                            md5sum = ((BEncodedString) keypair.Value).TextBytes;
                            break;

                        default:
                            break; //FIXME: Log unknown values
                    }
                }

                // A zero length file always belongs to the same piece as the previous file
                if (length == 0) {
                    if (files.Count > 0) {
                        startIndex = files[files.Count - 1].EndPieceIndex;
                        endIndex = files[files.Count - 1].EndPieceIndex;
                    } else {
                        startIndex = 0;
                        endIndex = 0;
                    }
                } else {
                    startIndex = (int) (size / pieceLength);
                    endIndex = (int) ((size + length) / pieceLength);
                    if ((size + length) % pieceLength == 0)
                        endIndex--;
                }

                PathValidator.Validate (path);
                files.Add (new TorrentFile (path, length, path, startIndex, endIndex, (int) (size % pieceLength), md5sum, ed2k, sha1));
                size += length;
            }

            torrentFiles = files.ToArray ();
        }


        /// <summary>
        /// This method is called internally to load the information found within the "Info" section
        /// of the .torrent file
        /// </summary>
        /// <param name="dictionary">The dictionary representing the Info section of the .torrent file</param>
        void ProcessInfo (BEncodedDictionary dictionary)
        {
            Metadata = dictionary.Encode ();
            pieceLength = int.Parse (dictionary["piece length"].ToString ());
            LoadHashPieces (((BEncodedString) dictionary["pieces"]).TextBytes);

            foreach (KeyValuePair<BEncodedString, BEncodedValue> keypair in dictionary) {
                switch (keypair.Key.Text) {
                    case ("source"):
                        Source = keypair.Value.ToString ();
                        break;

                    case ("sha1"):
                        SHA1 = ((BEncodedString) keypair.Value).TextBytes;
                        break;

                    case ("ed2k"):
                        ED2K = ((BEncodedString) keypair.Value).TextBytes;
                        break;

                    case ("publisher-url.utf-8"):
                        if (keypair.Value.ToString ().Length > 0)
                            PublisherUrl = keypair.Value.ToString ();
                        break;

                    case ("publisher-url"):
                        if ((string.IsNullOrEmpty (PublisherUrl)) && (keypair.Value.ToString ().Length > 0))
                            PublisherUrl = keypair.Value.ToString ();
                        break;

                    case ("publisher.utf-8"):
                        if (keypair.Value.ToString ().Length > 0)
                            Publisher = keypair.Value.ToString ();
                        break;

                    case ("publisher"):
                        if ((string.IsNullOrEmpty (Publisher)) && (keypair.Value.ToString ().Length > 0))
                            Publisher = keypair.Value.ToString ();
                        break;

                    case ("files"):
                        LoadTorrentFiles (((BEncodedList) keypair.Value));
                        break;

                    case ("name.utf-8"):
                        if (keypair.Value.ToString ().Length > 0)
                            name = keypair.Value.ToString ();
                        break;

                    case ("name"):
                        if ((string.IsNullOrEmpty (name)) && (keypair.Value.ToString ().Length > 0))
                            name = keypair.Value.ToString ();
                        break;

                    case ("piece length"):  // Already handled
                        break;

                    case ("length"):
                        break;      // This is a singlefile torrent

                    case ("private"):
                        IsPrivate = (keypair.Value.ToString () == "1") ? true : false;
                        break;

                    default:
                        break;
                }
            }

            if (torrentFiles == null)   // Not a multi-file torrent
            {
                long length = long.Parse (dictionary["length"].ToString ());
                size = length;
                string path = name;
                byte[] md5 = (dictionary.ContainsKey ("md5")) ? ((BEncodedString) dictionary["md5"]).TextBytes : null;
                byte[] ed2k = (dictionary.ContainsKey ("ed2k")) ? ((BEncodedString) dictionary["ed2k"]).TextBytes : null;
                byte[] sha1 = (dictionary.ContainsKey ("sha1")) ? ((BEncodedString) dictionary["sha1"]).TextBytes : null;

                torrentFiles = new TorrentFile[1];
                int endPiece = Math.Min (Pieces.Count - 1, (int) ((size + (pieceLength - 1)) / pieceLength));
                torrentFiles[0] = new TorrentFile (path, length, path, 0, endPiece, 0, md5, ed2k, sha1);
            }
        }

        #endregion Private Methods


        #region Loading methods

        /// <summary>
        /// This method loads a .torrent file from the specified path.
        /// </summary>
        /// <param name="path">The path to load the .torrent file from</param>
        public static Torrent Load (string path)
        {
            Check.Path (path);

            using Stream s = new FileStream (path, FileMode.Open, FileAccess.Read, FileShare.Read);
            return Load (s, path);
        }

        /// <summary>
        /// This method loads a .torrent file from the specified path.
        /// </summary>
        /// <param name="path">The path to load the .torrent file from</param>
        public static Task<Torrent> LoadAsync (string path)
        {
            return Task.Run (() => Load (path));
        }

        /// <summary>
        /// Loads a torrent from a byte[] containing the bencoded data
        /// </summary>
        /// <param name="data">The byte[] containing the data</param>
        /// <returns></returns>
        public static Torrent Load (byte[] data)
        {
            Check.Data (data);

            using var s = new MemoryStream (data);
            return Load (s, "");
        }

        /// <summary>
        /// Loads a torrent from a byte[] containing the bencoded data
        /// </summary>
        /// <param name="data">The byte[] containing the data</param>
        /// <returns></returns>
        public static Task<Torrent> LoadAsync (byte[] data)
        {
            return Task.Run (() => Load (data));
        }

        /// <summary>
        /// Loads a .torrent from the supplied stream
        /// </summary>
        /// <param name="stream">The stream containing the data to load</param>
        /// <returns></returns>
        public static Torrent Load (Stream stream)
        {
            Check.Stream (stream);

            if (stream == null)
                throw new ArgumentNullException (nameof (stream));

            return Load (stream, "");
        }

        /// <summary>
        /// Loads a .torrent from the supplied stream
        /// </summary>
        /// <param name="stream">The stream containing the data to load</param>
        /// <returns></returns>
        public static Task<Torrent> LoadAsync (Stream stream)
        {
            return Task.Run (() => Load (stream));
        }

        /// <summary>
        /// Loads a .torrent file from the specified URL
        /// </summary>
        /// <param name="url">The URL to download the .torrent from</param>
        /// <param name="location">The path to download the .torrent to before it gets loaded</param>
        /// <returns></returns>
        public static Torrent Load (Uri url, string location)
        {
            Check.Url (url);
            Check.Location (location);

            try {
                using var client = new WebClient ();
                client.DownloadFile (url, location);
            } catch (Exception ex) {
                File.Delete (location);
                throw new TorrentException ("Could not download .torrent file from the specified url", ex);
            }

            return Load (location);
        }

        /// <summary>
        /// Loads a .torrent file from the specified URL
        /// </summary>
        /// <param name="url">The URL to download the .torrent from</param>
        /// <param name="location">The path to download the .torrent to before it gets loaded</param>
        /// <returns></returns>
        public static async Task<Torrent> LoadAsync (Uri url, string location)
        {
            try {
                using var client = new WebClient ();
                await client.DownloadFileTaskAsync (url, location).ConfigureAwait (false);
            } catch (Exception ex) {
                File.Delete (location);
                throw new TorrentException ("Could not download .torrent file from the specified url", ex);
            }

            return await LoadAsync (location).ConfigureAwait (false);
        }

        /// <summary>
        /// Loads a .torrent from the specificed path. A return value indicates
        /// whether the operation was successful.
        /// </summary>
        /// <param name="path">The path to load the .torrent file from</param>
        /// <param name="torrent">If the loading was succesful it is assigned the Torrent</param>
        /// <returns>True if successful</returns>
        public static bool TryLoad (string path, out Torrent torrent)
        {
            Check.Path (path);

            torrent = null;
            try {
                if (!string.IsNullOrEmpty (path) && File.Exists (path))
                    torrent = Load (path);
            } catch {
                // We will return false if an exception is thrown as 'torrent' will still
                // be null.
            }

            return torrent != null;
        }

        /// <summary>
        /// Loads a .torrent from the specified byte[]. A return value indicates
        /// whether the operation was successful.
        /// </summary>
        /// <param name="data">The byte[] to load the .torrent from</param>
        /// <param name="torrent">If loading was successful, it contains the Torrent</param>
        /// <returns>True if successful</returns>
        public static bool TryLoad (byte[] data, out Torrent torrent)
        {
            Check.Data (data);

            try {
                torrent = Load (data);
            } catch {
                torrent = null;
            }

            return torrent != null;
        }

        /// <summary>
        /// Loads a .torrent from the supplied stream. A return value indicates
        /// whether the operation was successful.
        /// </summary>
        /// <param name="stream">The stream containing the data to load</param>
        /// <param name="torrent">If the loading was succesful it is assigned the Torrent</param>
        /// <returns>True if successful</returns>
        public static bool TryLoad (Stream stream, out Torrent torrent)
        {
            Check.Stream (stream);

            try {
                torrent = Load (stream);
            } catch {
                torrent = null;
            }

            return torrent != null;
        }

        /// <summary>
        /// Loads a .torrent file from the specified URL. A return value indicates
        /// whether the operation was successful.
        /// </summary>
        /// <param name="url">The URL to download the .torrent from</param>
        /// <param name="location">The path to download the .torrent to before it gets loaded</param>
        /// <param name="torrent">If the loading was succesful it is assigned the Torrent</param>
        /// <returns>True if successful</returns>
        public static bool TryLoad (Uri url, string location, out Torrent torrent)
        {
            Check.Url (url);
            Check.Location (location);

            try {
                torrent = Load (url, location);
            } catch {
                torrent = null;
            }

            return torrent != null;
        }

        /// <summary>
        /// Called from either Load(stream) or Load(string).
        /// </summary>
        /// <param name="stream"></param>
        /// <param name="path"></param>
        /// <returns></returns>
        static Torrent Load (Stream stream, string path)
        {
            Check.Stream (stream);
            Check.Path (path);

            try {
                Torrent t = LoadCore ((BEncodedDictionary) BEncodedValue.Decode (stream));
                t.torrentPath = path;
                return t;
            } catch (BEncodingException ex) {
                throw new TorrentException ("Invalid torrent file specified", ex);
            }
        }

        public static Torrent Load (BEncodedDictionary torrentInformation)
        {
            return LoadCore ((BEncodedDictionary) BEncodedValue.Decode (torrentInformation.Encode ()));
        }

        internal static Torrent LoadCore (BEncodedDictionary torrentInformation)
        {
            Check.TorrentInformation (torrentInformation);

            var t = new Torrent ();
            t.LoadInternal (torrentInformation);

            return t;
        }

        protected void LoadInternal (BEncodedDictionary torrentInformation)
        {
            Check.TorrentInformation (torrentInformation);
            originalDictionary = torrentInformation;
            torrentPath = "";

            foreach (KeyValuePair<BEncodedString, BEncodedValue> keypair in torrentInformation) {
                switch (keypair.Key.Text) {
                    case ("announce"):
                        // Ignore this if we have an announce-list
                        if (torrentInformation.ContainsKey ("announce-list"))
                            break;
                        AnnounceUrls.Add (new RawTrackerTier ());
                        AnnounceUrls[0].Add (keypair.Value.ToString ());
                        break;

                    case ("creation date"):
                        try {
                            try {
                                creationDate = creationDate.AddSeconds (long.Parse (keypair.Value.ToString ()));
                            } catch (Exception e) {
                                if (e is ArgumentOutOfRangeException)
                                    creationDate = creationDate.AddMilliseconds (long.Parse (keypair.Value.ToString ()));
                                else
                                    throw;
                            }
                        } catch (Exception e) {
                            if (e is ArgumentOutOfRangeException)
                                throw new BEncodingException ("Argument out of range exception when adding seconds to creation date.", e);
                            else if (e is FormatException)
                                throw new BEncodingException ($"Could not parse {keypair.Value} into a number", e);
                            else
                                throw;
                        }
                        break;

                    case ("nodes"):
                        if (keypair.Value is BEncodedList list)
                            Nodes = list;
                        break;

                    case ("comment.utf-8"):
                        if (keypair.Value.ToString ().Length != 0)
                            Comment = keypair.Value.ToString ();       // Always take the UTF-8 version
                        break;                                          // even if there's an existing value

                    case ("comment"):
                        if (string.IsNullOrEmpty (Comment))
                            Comment = keypair.Value.ToString ();
                        break;

                    case ("publisher-url.utf-8"):                       // Always take the UTF-8 version
                        PublisherUrl = keypair.Value.ToString ();      // even if there's an existing value
                        break;

                    case ("publisher-url"):
                        if (string.IsNullOrEmpty (PublisherUrl))
                            PublisherUrl = keypair.Value.ToString ();
                        break;

                    case ("azureus_properties"):
                        AzureusProperties = keypair.Value;
                        break;

                    case ("created by"):
                        CreatedBy = keypair.Value.ToString ();
                        break;

                    case ("encoding"):
                        Encoding = keypair.Value.ToString ();
                        break;

                    case ("info"):
                        using (SHA1 s = HashAlgoFactory.Create<SHA1> ())
                            InfoHash = new InfoHash (s.ComputeHash (keypair.Value.Encode ()));
                        ProcessInfo (((BEncodedDictionary) keypair.Value));
                        break;

                    case ("name"):                                               // Handled elsewhere
                        break;

                    case ("announce-list"):
                        if (keypair.Value is BEncodedString)
                            break;
                        var announces = (BEncodedList) keypair.Value;

                        for (int j = 0; j < announces.Count; j++) {
                            if (announces[j] is BEncodedList bencodedTier) {
                                var tier = new List<string> (bencodedTier.Count);

                                for (int k = 0; k < bencodedTier.Count; k++)
                                    tier.Add (bencodedTier[k].ToString ());

                                Toolbox.Randomize (tier);

                                var collection = new RawTrackerTier ();
                                for (int k = 0; k < tier.Count; k++)
                                    collection.Add (tier[k]);

                                if (collection.Count != 0)
                                    AnnounceUrls.Add (collection);
                            } else {
                                throw new BEncodingException (
                                    $"Non-BEncodedList found in announce-list (found {announces[j].GetType ()})");
                            }
                        }
                        break;

                    case ("httpseeds"):
                        // This form of web-seeding is not supported.
                        break;

                    case ("url-list"):
                        if (keypair.Value is BEncodedString) {
                            GetRightHttpSeeds.Add (((BEncodedString) keypair.Value).Text);
                        } else if (keypair.Value is BEncodedList) {
                            foreach (BEncodedString str in (BEncodedList) keypair.Value)
                                GetRightHttpSeeds.Add (str.Text);
                        }
                        break;

                    default:
                        break;
                }
            }
        }

        #endregion Loading methods
    }
}
